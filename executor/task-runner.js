/**
 * Task Runner - Executes inside Docker container
 * This runs within the isolated container
 */

import { Redis } from 'ioredis';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Load configuration
const configPath = process.env.CONFIG_PATH || '/app/config/default.json';
const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));

// Redis client
const redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');

/**
 * Send progress update
 */
async function sendProgress(progress) {
  const taskId = process.env.TASK_ID;
  if (!taskId) return;
  
  const data = {
    taskId,
    ...progress,
    timestamp: new Date().toISOString(),
  };
  
  try {
    await redis.publish(`${config.redis?.keyPrefix || 'agent:'}progress:${taskId}`, JSON.stringify(data));
  } catch (e) {
    // Ignore errors
  }
}

/**
 * Execute a task with available tools
 */
async function executeTask(taskData) {
  const { id: taskId, task, tools } = taskData;
  const results = {
    taskId,
    executedAt: new Date().toISOString(),
    steps: [],
    output: '',
  };

  await sendProgress({
    progress: 20,
    step: 'analyzing',
    message: 'Analyzing task requirements',
  });

  const steps = [];
  
  if (tools.includes('web_search')) {
    await sendProgress({
      progress: 40,
      step: 'searching',
      message: 'Searching for relevant information',
    });
    
    steps.push({
      tool: 'web_search',
      action: 'Search for relevant information',
      query: task.substring(0, 50),
      status: 'success',
    });
  }
  
  await sendProgress({
    progress: 60,
    step: 'processing',
    message: 'Processing information with AI',
  });
  
  if (tools.includes('llm')) {
    steps.push({
      tool: 'llm',
      action: 'Generate response using LLM',
      status: 'success',
      model: 'gpt-4o',
    });
  }
  
  if (tools.includes('github')) {
    await sendProgress({
      progress: 80,
      step: 'github',
      message: 'Performing GitHub operations',
    });
    
    steps.push({
      tool: 'github',
      action: 'GitHub operations',
      status: 'success',
      operations: ['read', 'write'],
    });
  }

  await sendProgress({
    progress: 90,
    step: 'formatting',
    message: 'Formatting output',
  });

  // Generate output based on task type
  let output = '';
  
  if (task.toLowerCase().includes('travel') || task.toLowerCase().includes('æ—…æ¸¸')) {
    output = generateTravelPlan(task);
  } else if (task.toLowerCase().includes('github') || task.toLowerCase().includes('code')) {
    output = generateGitHubPlan(task);
  } else {
    output = generateGeneralResponse(task);
  }

  results.steps = steps;
  results.output = output;
  results.executedAt = new Date().toISOString();

  await sendProgress({
    progress: 100,
    step: 'completed',
    message: 'Task completed',
  });

  return results;
}

/**
 * Generate travel plan (example)
 */
function generateTravelPlan(task) {
  return `# ğŸŒ æ—…è¡Œè§„åˆ’

## ä»»åŠ¡ï¼š${task}

### ğŸ“‹ æ¨èè¡Œç¨‹

**Day 1-2: ç›®çš„åœ°æ¢ç´¢**
- æŠµè¾¾å¹¶å…¥ä½é…’åº—
- å½“åœ°æ™¯ç‚¹åˆæ¢
- å½“åœ°ç¾é£Ÿä½“éªŒ

**Day 3-4: æ·±åº¦æ¸¸è§ˆ**
- ä¸»è¦æ™¯ç‚¹æ¸¸è§ˆ
- æ–‡åŒ–ä½“éªŒ
- å½“åœ°ç‰¹è‰²æ´»åŠ¨

**Day 5-6: ä¼‘é—²æ”¾æ¾**
- è‡ªç„¶é£å…‰æ¢ç´¢
- è´­ç‰©ä¼‘é—²
- ç¾é£Ÿæ¢ç´¢

### ğŸ“¦ å¿…å¤‡ç‰©å“æ¸…å•
- [ ] æŠ¤ç…§/èº«ä»½è¯
- [ ] æ¢æ´—è¡£ç‰©
- [ ] å……ç”µå™¨
- [ ] å¸¸ç”¨è¯å“
- [ ] æ—…è¡Œä¿é™©

### ğŸ’° é¢„ç®—ä¼°ç®—
- äº¤é€šï¼š$500-1000
- ä½å®¿ï¼š$800-1500
- é¤é¥®ï¼š$300-600
- é—¨ç¥¨ï¼š$200-400

---
*Generated by Agent Sandbox*
`;
}

/**
 * Generate GitHub plan (example)
 */
function generateGitHubPlan(task) {
  return `# ğŸ“¦ GitHub ä»»åŠ¡è§„åˆ’

## ä»»åŠ¡ï¼š${task}

### ğŸ”§ æ‰§è¡Œæ­¥éª¤

1. **ä»£ç å‡†å¤‡**
   - å…‹éš†ä»“åº“
   - åˆ›å»ºåˆ†æ”¯
   - å®ç°åŠŸèƒ½

2. **æµ‹è¯•éªŒè¯**
   - å•å…ƒæµ‹è¯•
   - é›†æˆæµ‹è¯•
   - ä»£ç å®¡æŸ¥

3. **æäº¤å‘å¸ƒ**
   - æäº¤ä»£ç 
   - åˆ›å»º Pull Request
   - åˆå¹¶åˆ°ä¸»åˆ†æ”¯

### ğŸ“ ä»£ç ç¤ºä¾‹

\`\`\`javascript
// ç¤ºä¾‹ä»£ç 
function example() {
  console.log('Hello, World!');
}
\`\`\`

---
*Generated by Agent Sandbox*
`;
}

/**
 * Generate general response (example)
 */
function generateGeneralResponse(task) {
  return `# ğŸ“‹ ä»»åŠ¡æ‰§è¡Œç»“æœ

## åŸå§‹ä»»åŠ¡
${task}

## ğŸ¤– æ‰§è¡Œæ‘˜è¦

ä»»åŠ¡å·²æˆåŠŸå¤„ç†ï¼

### ä½¿ç”¨çš„å·¥å…·
- âœ… LLM (GPT-4o)
- âœ… ä¿¡æ¯æœç´¢
- âœ… ä»£ç æ‰§è¡Œ

### ğŸ“Š çŠ¶æ€
- çŠ¶æ€ï¼šâœ… å®Œæˆ
- æ—¶é—´ï¼š${new Date().toLocaleString()}

---
*Generated by Agent Sandbox*
`;
}

/**
 * Main entry point
 */
async function main() {
  const taskId = process.env.TASK_ID;
  
  if (!taskId) {
    console.error('âŒ TASK_ID not set');
    process.exit(1);
  }

  console.log(`ğŸš€ Starting task: ${taskId}`);

  try {
    // Read task file
    const taskFile = path.join(config.docker?.workspacePath || '/app/workspace', `${taskId}.json`);
    
    let taskData;
    
    if (fs.existsSync(taskFile)) {
      taskData = JSON.parse(fs.readFileSync(taskFile, 'utf-8'));
    } else {
      // Try to get from Redis
      taskData = JSON.parse(await redis.get(`${config.redis?.keyPrefix || 'agent:'}task:${taskId}`));
    }
    
    // Execute
    const results = await executeTask(taskData);
    
    // Write result
    const resultFile = path.join(config.docker?.workspacePath || '/app/workspace', `${taskId}_result.json`);
    fs.writeFileSync(resultFile, JSON.stringify(results, null, 2));
    
    console.log(`âœ… Task completed: ${taskId}`);
    console.log(`ğŸ“„ Result written to: ${resultFile}`);
    
    process.exit(0);
  } catch (error) {
    console.error(`âŒ Task failed: ${error.message}`);
    
    // Write error result
    const resultFile = path.join(config.docker?.workspacePath || '/app/workspace', `${taskId}_result.json`);
    fs.writeFileSync(resultFile, JSON.stringify({
      taskId,
      status: 'failed',
      error: error.message,
    }, null, 2));
    
    process.exit(1);
  }
}

main();
