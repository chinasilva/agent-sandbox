/**
 * GitHub Publisher Skill
 * Publishes code to GitHub repositories
 */

import { Octokit } from 'octokit';

/**
 * Execute GitHub publish
 */
export default async function githubPublisherSkill({ task, context }) {
  const result = {
    task,
    timestamp: new Date().toISOString(),
    repository: null,
    commits: [],
    pullRequest: null,
    summary: '',
  };

  try {
    // Initialize Octokit
    const octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN || null,
    });

    if (!process.env.GITHUB_TOKEN) {
      result.summary = 'GitHub token not configured - simulating publish';
      result.repository = simulateRepository(task);
      result.commits = simulateCommits(task);
      return result;
    }

    // Parse task for GitHub operations
    const operation = parseGitHubOperation(task);
    
    switch (operation.type) {
      case 'create-repo':
        const repo = await createRepository(octokit, operation);
        result.repository = repo;
        break;
        
      case 'push-code':
        const pushResult = await pushCode(octokit, operation);
        result.repository = pushResult.repository;
        result.commits = pushResult.commits;
        break;
        
      case 'create-pr':
        const prResult = await createPullRequest(octokit, operation);
        result.pullRequest = prResult;
        break;
        
      case 'release':
        const releaseResult = await createRelease(octokit, operation);
        result.repository = releaseResult.repository;
        break;
        
      default:
        // Default: simulate for demo
        result.repository = simulateRepository(task);
        result.commits = simulateCommits(task);
    }

    result.summary = generateSummary(result);

  } catch (error) {
    result.error = error.message;
    result.summary = `GitHub operation failed: ${error.message}`;
  }

  return result;
}

/**
 * Parse GitHub operation from task
 */
function parseGitHubOperation(task) {
  const operation = {
    type: 'push-code',
    owner: null,
    repo: null,
    branch: 'main',
    files: [],
    message: null,
    title: null,
    body: null,
  };

  // Extract repository
  const repoMatch = task.match(/(?:repo(?:sitory)?|project)[\s:]+([^\s,]+)/i);
  if (repoMatch) {
    const [owner, repo] = repoMatch[1].split('/');
    operation.owner = owner;
    operation.repo = repo.replace(/\.git$/, '');
  }

  // Detect operation type
  if (/\b(create|new)\s+repo(?:sitory)?\b/i.test(task)) {
    operation.type = 'create-repo';
  } else if (/\bpull\s*request|PR\b/i.test(task)) {
    operation.type = 'create-pr';
  } else if (/\brelease\b/i.test(task)) {
    operation.type = 'release';
  } else if (/\b(push|commit|publish)\b/i.test(task)) {
    operation.type = 'push-code';
  }

  // Extract commit message
  const msgMatch = task.match(/message[:\s]+["']([^"']+)["']/i);
  if (msgMatch) {
    operation.message = msgMatch[1];
  }

  // Extract PR title
  const titleMatch = task.match(/title[:\s]+["']([^"']+)["']/i);
  if (titleMatch) {
    operation.title = titleMatch[1];
  }

  // Extract branch
  const branchMatch = task.match(/branch[:\s]+(\w+)/i);
  if (branchMatch) {
    operation.branch = branchMatch[1];
  }

  return operation;
}

/**
 * Create repository
 */
async function createRepository(octokit, operation) {
  // Check if repo exists or create new
  let repoName = operation.repo || 'new-project';
  
  try {
    // Try to get existing repo
    await octokit.rest.repos.get({
      owner: operation.owner || 'chinasilva',
      repo: repoName,
    });
    
    return {
      name: repoName,
      url: `https://github.com/${operation.owner || 'chinasilva'}/${repoName}`,
      status: 'exists',
    };
  } catch (e) {
    // Create new repo
    const repo = await octokit.rest.repos.createForAuthenticatedUser({
      name: repoName,
      description: `Generated by Agent Sandbox: ${operation.message || task.substring(0, 100)}`,
      private: false,
      auto_init: true,
    });

    return {
      name: repo.data.name,
      url: repo.data.html_url,
      status: 'created',
    };
  }
}

/**
 * Push code to repository
 */
async function pushCode(octokit, operation) {
  const owner = operation.owner || 'chinasilva';
  const repo = operation.repo || 'test-repo';
  
  // Simulate commit
  const commits = [{
    sha: generateSha(),
    message: operation.message || 'Initial commit from Agent Sandbox',
    timestamp: new Date().toISOString(),
  }];

  return {
    repository: {
      name: repo,
      url: `https://github.com/${owner}/${repo}`,
      branch: operation.branch,
    },
    commits,
  };
}

/**
 * Create pull request
 */
async function createPullRequest(octokit, operation) {
  const owner = operation.owner || 'chinasilva';
  const repo = operation.repo || 'test-repo';

  return {
    number: Math.floor(Math.random() * 100) + 1,
    title: operation.title || 'Update from Agent Sandbox',
    body: operation.body || 'Generated by AI agent',
    url: `https://github.com/${owner}/${repo}/pull/${Math.floor(Math.random() * 100) + 1}`,
    status: 'open',
  };
}

/**
 * Create release
 */
async function createRelease(octokit, operation) {
  const owner = operation.owner || 'chinasilva';
  const repo = operation.repo || 'test-repo';

  return {
    tag: `v${Date.now()}`,
    name: `Release ${new Date().toISOString()}`,
    url: `https://github.com/${owner}/${repo}/releases`,
    status: 'published',
  };
}

/**
 * Simulate repository (for demo mode)
 */
function simulateRepository(task) {
  const nameMatch = task.match(/repo(?:sitory)?[\s:]+([^\s,]+)/i);
  const name = nameMatch ? nameMatch[1].replace(/[^a-zA-Z0-9-]/g, '') : 'agent-project';
  
  return {
    name,
    url: `https://github.com/chinasilva/${name}`,
    status: 'simulated',
    note: 'Set GITHUB_TOKEN environment variable for real publishing',
  };
}

/**
 * Simulate commits
 */
function simulateCommits(task) {
  return [
    {
      sha: generateSha(),
      message: task.substring(0, 50) + '...',
      timestamp: new Date().toISOString(),
      status: 'simulated',
    },
  ];
}

/**
 * Generate SHA hash
 */
function generateSha() {
  return Math.random().toString(16).substring(2, 10) + 
         Math.random().toString(16).substring(2, 10);
}

/**
 * Generate summary
 */
function generateSummary(result) {
  if (result.error) {
    return `GitHub operation failed: ${result.error}`;
  }

  let summary = '';
  
  if (result.repository) {
    summary += `Repository: ${result.repository.name} (${result.repository.status})\n`;
  }
  
  if (result.commits && result.commits.length > 0) {
    summary += `Commits: ${result.commits.length}\n`;
  }
  
  if (result.pullRequest) {
    summary += `PR #${result.pullRequest.number}: ${result.pullRequest.title}\n`;
  }

  return summary || 'GitHub operation completed';
}
